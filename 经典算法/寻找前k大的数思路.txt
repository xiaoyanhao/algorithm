思路1：    部分堆排序，复杂度O(N*lgK)
    先把前K个数建立成最小堆，这样堆顶就是前K个里面最小的一个。
    接下来往后继续遍历，遇到比堆顶大的元素Big就把堆顶元素删除，再将Big插入堆（这时候要调整保持它是最小堆）
    遍历完之后，这个堆里面的K个元素就是前K大的元素了，接下来就是降序输出了，大家都会的
    理由：每次遇到一个较大的元素，都把目前最小的元素删掉，最后留下来的自然就是前K大的了
    注意，要理解为什么是最小堆，面试答错了就惨了，人家会觉得你根本就没有理解这到底是怎么做的。
    
后面这两种思路不一定能过：
思路2：    部分快速排序，复杂度O(N*K)
    按照快排的思想，先找个中枢p，然后把这N个数分成两部分，一部分大于p，另一部分小于p
    我们记大于p部分的元素个数为size，则：
    如果size > k，说明前K大的数都在这里面，继续按照快排的思想找个中枢然后分成两部分
    如果size = k，那就正好是这k个数了，接下来就是降序输出了
    如果size < k，那么说明前size大的数在这里面，我们还需要到小于p的部分里面找 (k-size) 个数
                    一样是继续按照快排的思想找个中枢然后将小于p的部分分成两部分
    注意，如果是大数据，可能会超过内存，那么就不能用这种方法了，因为你需要很多次文件读写，这是很耗时的
    另外两种思路都是扫描一次文件就可以了，不管文件有多大，需要维持的空间仅仅是K个数的空间而已。
    
思路3：    局部淘汰插入排序，复杂度O(N*K)
    将前K个元素排序，然后每次对后面的元素进行插入排序到前K个元素就好了